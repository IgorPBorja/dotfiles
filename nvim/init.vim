" Set space as map leader 
" first make sure it is not mapped to anything
nnoremap <Space> <Nop>
" Set mapleader
let mapleader=" "

" -------- PLUGINS ------------------------------------
" Uninstall plugins removing their respectives lines from .vimrc and running PlugClean
" See https://github.com/junegunn/vim-plug/issues/121

" For nnn plugin:  https://github.com/mcchrish/nnn.vim
call plug#begin('~/.vim/plugged')

	" Plug 'dense-analysis/ale'
	Plug 'preservim/nerdcommenter'
	" Plug 'mcchrish/nnn.vim'
	Plug 'preservim/nerdtree'	
	Plug 'jiangmiao/auto-pairs'
	
	" Tree-sitter for syntax-hightlighting
	Plug 'nvim-treesitter/nvim-treesitter'
	" Completion derived from AST generated by tree-sitter
	Plug 'haorenW1025/completion-nvim'
	Plug 'nvim-treesitter/completion-treesitter'

	" LSP support
	Plug 'neovim/nvim-lsp'
	" LSP easy configuration (adding language servers, etc)
	Plug 'neovim/nvim-lspconfig'
	" Autocomplete plugin, using the data generated by the lsp
	" Plug 'hrsh7th/nvim-compe' (deprecated!)
	" Sucessor:
	" Dependencies
	Plug 'hrsh7th/cmp-nvim-lsp'
	Plug 'hrsh7th/cmp-buffer'
	Plug 'hrsh7th/cmp-path'
	Plug 'hrsh7th/cmp-cmdline'
	" Plugin itself
	Plug 'hrsh7th/nvim-cmp'

	" vsnippet
	Plug 'hrsh7th/vim-vsnip'
	Plug 'hrsh7th/vim-vsnip-integ'
	Plug 'hrsh7th/cmp-vsnip'
	Plug 'hrsh7th/vim-vsnip'

	" Use copilot?
	Plug 'github/copilot.vim'

	" autocompletion with deoplete
	" Plug 'Shougo/deoplete.nvim'
	" do tab autocompletion in insert mode (w/o having to switch to normal mode)
	" Plug 'ervandew/supertab'

	" Telescope dependency
	Plug 'nvim-lua/plenary.nvim'
	" Telescope: searching for patterns in folders and projects
	Plug 'nvim-telescope/telescope.nvim', { 'tag': '0.1.3' }	
	
	" Coc autocompletion and language servers
	" Plug 'neoclide/coc.nvim', {'branch': 'release'}
	
	" Creating, renaming, deleting and copying files with this telescope picker
	Plug 'nvim-telescope/telescope-file-browser.nvim'

	" Lualine: useful information (mode, git branch, etc)
	Plug 'nvim-lualine/lualine.nvim'
	" Tabline: buffer visualization
	" Plug 'crispgm/nvim-tabline'
	" Recommended (for coloured icons)
	Plug 'nvim-tree/nvim-web-devicons'  
	" better
	Plug 'akinsho/bufferline.nvim'

	" TODO/FIXME syntax-hightlighting
	Plug 'folke/todo-comments.nvim'

	" Plugin for Racket
	Plug 'wlangstroth/vim-racket'
call plug#end()


" -------- KEYBINDINGS --------------------------------

" See https://www.freecodecamp.org/news/vimrc-configuration-guide-customize-your-vim-editor/

" disable compatibility with vi which can cause unexpected issues
set nocompatible

" filetype detection
filetype on
filetype plugin on
filetype indent on

" Gruvbox dark theme
" See https://github.com/morhetz/gruvbox
" Colors effectively on ~/.vim/colors
syntax enable
set background=dark
colorscheme gruvbox 

set autoindent
set tabstop=4
set shiftwidth=4
set number
" no word wrap after colum 80
set wrap " display lines as wrapped 
set tw=0 " do not physically wrap lines (inserting newlines)

" relative line numbering (makes jumps easier)
set relativenumber

" Use space characters instead of tabs.
" set expandtab

" Forget about swap files (but still save them)
set shortmess+=A

" Do not let cursor scroll below or above N number of lines when scrolling.
set scrolloff=10

" Show the mode you are on the last line.
set showmode

" Show matching words during a search.
set showmatch

" Use highlighting when doing a search.
set hlsearch

" Enable auto completion menu after pressing TAB.
set wildmenu

" Make wildmenu behave like similar to Bash completion.
set wildmode=list:longest

" There are certain files that we would never want to edit with Vim.
" Wildmenu will ignore files with these extensions.
set wildignore=*.docx,*.jpg,*.png,*.gif,*.pdf,*.pyc,*.exe,*.flv,*.img,*.xlsx

" renoremap Ctrl + down to move five lines down

noremap <C-Up> 5k
noremap <C-Down> 5j
noremap <C-j> 5j
" unmap C-k first (it is mapped by default in neovim to bookmark)
noremap <C-k> <Nop>
noremap <C-k> 5k
noremap <C-h> 5h
noremap <C-l> 5l
inoremap <C-j> <Esc>5ji
inoremap <C-k> <Esc>5ki
inoremap <C-h> <Esc>5hi
inoremap <C-l> <Esc>5hl

" TODO: configure undo-tree 
" Normal mode: simple undo
nnoremap <C-z> u
" unmap real u
nnoremap u <Nop>
" Insert mode: go to normal mode, do undo, go back to insert mode
inoremap <C-z> <Esc>ui 

" Change windows 
noremap <C-S-Left> <C-w>h 
noremap <C-S-Right> <C-w>l
noremap <C-S-Up> <C-w>k
noremap <C-S-Down> <C-w>j
" Change windows (alternative)
nnoremap <Space><Left> <C-w>h
nnoremap <Space><Right> <C-w>l
nnoremap <Space><Up> <C-w>k
nnoremap <Space><Down> <C-w>j
" Change windows (alternative 2)
nnoremap <Space>h <C-w>h
nnoremap <Space>l <C-w>l
nnoremap <Space>k <C-w>k
nnoremap <Space>j <C-w>j

" Split windows and term
" <CR> = carriage return 
" see https://stackoverflow.com/questions/1851225/noremapping-a-sequence-of-keystrokes-to-command-line-commands
" open terminal (new tab)
" see  https://vi.stackexchange.com/questions/24806/how-to-open-a-terminal-horizontally-on-the-right-side-of-vim
nnoremap <Space>t :tabnew<CR>:term<CR>
" horizontal split
nnoremap <Space><Tab>n :vsp<CR>
" vertical split
nnoremap <Space><Tab>nv :sp<CR>

" mapping 'copy/paste from system clipboard' (+ register, accesed via "+) 
nnoremap <C-v> "+p
inoremap <C-v> <Esc>"+pi
vnoremap <C-c> "+y
" copy line
nnoremap <C-c> "+yy

" Go to end of the line (usually $ in normal mode), without changing modes
nnoremap <C-e> <S-a>
inoremap <C-e> <Esc><S-a>
" Or using 9 in normal mode
nnoremap 9 $

" Go to the beggining of the line (usually 0 in normal mode), without changing modes
nnoremap <C-a> <S-i>
inoremap <C-a> <Esc><S-i>

" Open new tab and move between tabs. Also tab deletion/creation
nnoremap <C-t> :enew<CR>
nnoremap <C-w> :bdelete<CR>
" Force delete
nnoremap <C-w>! :bdelete!<CR>
nnoremap <C-x>n :bn<CR>
nnoremap <C-x>p :bp<CR>
nnoremap <leader><Tab> :bn<CR>
nnoremap <leader><S-Tab> :bp<CR>

" Show NERDTREE, just like vscode
nnoremap <C-E> :NERDTree<CR>

" Source .vimrc with SPC-h-r-r in normal mode
nnoremap <Space>hrr :source $MYVIMRC<CR>

" Quit with q + Enter (instead of recording) in NORMAL MODE
nnoremap q :q
" Quit without asking 
nnoremap qq :q<CR>
" Quit without asking (forceful)
nnoremap q! :q!<CR>

" Use a line cursor within insert mode and a block cursor everywhere else.
"
" Reference chart of values:
"   Ps = 0  -> blinking block.
"   Ps = 1  -> blinking block (default).
"   Ps = 2  -> steady block.
"   Ps = 3  -> blinking underline.
"   Ps = 4  -> steady underline.
"   Ps = 5  -> blinking bar (xterm).
"   Ps = 6  -> steady bar (xterm).
let &t_SI = "\e[6 q"
let &t_EI = "\e[2 q"

"" nerdcommenter
" Create default mappings
" see https://github.com/preservim/nerdcommenter
let g:NERDCreateDefaultMappings = 1

" Add spaces after comment delimiters by default
let g:NERDSpaceDelims = 1

" Use compact syntax for prettified multi-line comments
let g:NERDCompactSexyComs = 1

" Align line-wise comment delimiters flush left instead of following code indentation
let g:NERDDefaultAlign = 'left'

" Set a language to use its alternate delimiters by default
let g:NERDAltDelims_java = 1

" Add your own custom formats or override the defaults
let g:NERDCustomDelimiters = { 'c': { 'left': '/**','right': '*/' } }

" Allow commenting and inverting empty lines (useful when commenting a region)
let g:NERDCommentEmptyLines = 1

" Enable trimming of trailing whitespace when uncommenting
let g:NERDTrimTrailingWhitespace = 1

" Enable NERDCommenterToggle to check all selected lines is commented or not 
let g:NERDToggleCheckAllLines = 1

"" see count of matches of search (/) in vim
"" see https://stackoverflow.com/questions/4668623/show-count-of-matches-in-vim
set shortmess-=S

"" deal with '$TERM = screen' case
"" see https://superuser.com/questions/401926/how-to-get-shiftarrows-and-ctrlarrows-working-in-vim-in-tmux
if &term =~ '^screen'
	" tmux will send xterm-style keys when its xterm-keys option is on
	execute "set <xUp>=\e[1;*A"
	execute "set <xDown>=\e[1;*B"
	execute "set <xRight>=\e[1;*C"
	execute "set <xLeft>=\e[1;*D"
endif

"" Selecting with C-S-Arrow
nnoremap <C-S-Right> v<C-Right>
nnoremap <C-S-Left> v<C-Left>
vnoremap <C-S-Right> <C-Right>
vnoremap <C-S-Left> <C-Left>
inoremap <C-S-Right> <Esc>v<C-Right>
inoremap <C-S-Left> <Esc>v<C-Left>

"" Terminal remap
"" Terminal mode is the terminal insert mode
"" The terminal-related normal mode is the same as the normal mode
"" exit and go to normal mode
tnoremap <Esc> <C-\><C-n> 
"" quitting is always forceful (jobs will always be running)


" Some notes on nnn plugin
" To stop focusing on window type ESC 
" To show hidden files hit dot (.) 

" Opens the nÂ³ window in a spli" t
" let g:nnn#layout = 'vnew' " or vnew, tabnew etc.
" nnoremap <Space>f :NnnExplorer<CR>
"

" ----------- LATEX -----------
"" Latex file autocloses
autocmd FileType tex inoremap \( \(\)<Left><Left>
autocmd FileType tex inoremap \[ \[\]<Left><Left>
autocmd FileType tex inoremap \{ \{\}<Left><Left>
autocmd FileType tex inoremap _ _{}<Left>
autocmd FileType tex inoremap ^ ^{}<Left>
autocmd FileType plaintex inoremap \( \(\)<Left><Left>
autocmd FileType plaintex inoremap \[ \[\]<Left><Left>
autocmd FileType plaintex inoremap \{ \{\}<Left><Left>
autocmd FileType plaintex inoremap _ _{}<Left>
autocmd FileType plaintex inoremap ^ ^{}<Left>
"" Latex compilation
" Steps:
" 1. Save buffer name (relative to current working directory / cwd), which is
" expressed by 'expand("%:t") in register @
" open terminal window 
" execute pdflatex in that file

"" see https://stackoverflow.com/questions/3213657/vim-how-to-pass-arguments-to-functions-from-user-commands

function Compile(basename, ext)
	echo "Compiling"
	let filename = a:basename . "." . a:ext
	if (a:ext == "tex")
		"" disable interactive mode (pressing enter to skip warnings)
		"" this makes it possible to use pdflatex in script, like this one
		exe ":!pdflatex -interaction=nonstopmode " . filename
	endif
	if (a:ext == "md")
		exe ":!pandoc " . filename . " -o " a:basename . ".pdf"
	endif
endfunction

function CompileFromVim()
	let basename = expand("%:r")
	let ext = expand("%:e")
	call Compile(basename, ext)
endfunction

function Display()
	let basename = expand("%:r")
	call CompileFromVim()
	exe ":!xdg-open " . basename . ".pdf &"
endfunction

" autocmd FileType tex nnoremap <Space>p :let @" = expand("%")<CR>:exe ":!pdflatex " . getreg("@") <CR>
" autocmd FileType plaintex nnoremap <Space>p :let @" = expand("%")<CR>:exe ":!pdflatex " . getreg("@") <CR>
autocmd Filetype tex nnoremap <Space>d :call Display()<CR>
autocmd Filetype plaintex nnoremap <Space>d :call Display()<CR>
autocmd Filetype markdown nnoremap <Space>d :call Display()<CR>
autocmd Filetype tex nnoremap <Space>p :call CompileFromVim()<CR>
autocmd Filetype plaintex nnoremap <Space>p :call CompileFromVim()<CR>
autocmd Filetype markdown nnoremap <Space>p :call CompileFromVim()<CR>


lua <<
	require('nvim-treesitter.configs').setup {
	  -- A list of parser names, or "all" (the five listed parsers should always be installed)
	  ensure_installed = { 'c', 'cpp', 'go', 'lua', 'python', 'rust', 'typescript', 'vimdoc', 'cmake' },

	  -- Install parsers synchronously (only applied to `ensure_installed`)
	  sync_install = false,

	  -- Automatically install missing parsers when entering buffer
	  -- Recommendation: set to false if you don't have `tree-sitter` CLI installed locally
	  auto_install = true,

	  ---- If you need to change the installation directory of the parsers (see -> Advanced Setup)
	  -- parser_install_dir = "/some/path/to/store/parsers", -- Remember to run vim.opt.runtimepath:append("/some/path/to/store/parsers")!

	  highlight = {
		enable = true,

		-- NOTE: these are the names of the parsers and not the filetype. (for example if you want to
		-- disable highlighting for the `tex` filetype, you need to include `latex` in this list as this is
		-- the name of the parser)
		-- list of language that will be disabled
		disable = { "c", "rust" },
		-- Or use a function for more flexibility, e.g. to disable slow treesitter highlight for large files
		disable = function(lang, buf)
			local max_filesize = 100 * 1024 -- 100 KB
			local ok, stats = pcall(vim.loop.fs_stat, vim.api.nvim_buf_get_name(buf))
			if ok and stats and stats.size > max_filesize then
				return true
			end
		end,

		-- Setting this to true will run `:h syntax` and tree-sitter at the same time.
		-- Set this to `true` if you depend on 'syntax' being enabled (like for indentation).
		-- Using this option may slow down your editor, and you may see some duplicate highlights.
		-- Instead of true it can also be a list of languages
		additional_vim_regex_highlighting = false,
	  },
	}
.

" Configure LSP 
" copied from https://github.com/neovim/nvim-lspconfig

lua<<
	-- Setup language servers.
	local lspconfig = require('lspconfig')
	lspconfig.pyright.setup {}
	lspconfig.tsserver.setup {}
	lspconfig.clangd.setup {}
	lspconfig.rust_analyzer.setup {
	  -- Server-specific settings. See `:help lspconfig-setup`
	  settings = {
		['rust-analyzer'] = {},
	  },
	}

	-- Global mappings.
	-- See `:help vim.diagnostic.*` for documentation on any of the below functions
	vim.keymap.set('n', '<space>e', vim.diagnostic.open_float)
	vim.keymap.set('n', '[d', vim.diagnostic.goto_prev)
	vim.keymap.set('n', ']d', vim.diagnostic.goto_next)
	vim.keymap.set('n', '<space>q', vim.diagnostic.setloclist)

	-- Use LspAttach autocommand to only map the following keys
	-- after the language server attaches to the current buffer
	vim.api.nvim_create_autocmd('LspAttach', {
	  group = vim.api.nvim_create_augroup('UserLspConfig', {}),
	  callback = function(ev)
		-- Enable completion triggered by <c-x><c-o>
		vim.bo[ev.buf].omnifunc = 'v:lua.vim.lsp.omnifunc'

		-- Buffer local mappings.
		-- See `:help vim.lsp.*` for documentation on any of the below functions
		local opts = { buffer = ev.buf }
		vim.keymap.set('n', 'gD', vim.lsp.buf.declaration, opts)
		vim.keymap.set('n', 'gd', vim.lsp.buf.definition, opts)
		vim.keymap.set('n', 'K', vim.lsp.buf.hover, opts)
		vim.keymap.set('n', 'gi', vim.lsp.buf.implementation, opts)
		vim.keymap.set('n', '<C-k>', vim.lsp.buf.signature_help, opts)
		vim.keymap.set('n', '<space>D', vim.lsp.buf.type_definition, opts)
		vim.keymap.set('n', '<F2>', vim.lsp.buf.rename, opts)
		vim.keymap.set('n', 'gr', vim.lsp.buf.references, opts)
	  end,
	})
.

" ----------------- COC -----------------------
" " See https://stackoverflow.com/questions/74158726/vimscript-calling-function-inside-inoremap-throws-unknown-function
" " Use tab for trigger completion with characters ahead and navigate
" " NOTE: There's always complete item selected by default, you may want to enable
" " no select by `"suggest.noselect": true` in your configuration file
" " NOTE: Use command ':verbose imap <tab>' to make sure tab is not mapped by
" " other plugin before putting this into your config
" inoremap <silent><expr> <Tab>
"        \ coc#pum#visible() ? coc#pum#next(1) :
"       \ CheckBackspace() ? "\<Tab>" :
"       \ coc#refresh()
" inoremap <expr> <S-Tab> coc#pum#visible() ? coc#pum#prev(1) : "\<C-h>"
"
" " Accpet completion with Tab
" inoremap <silent><expr> <TAB> coc#pum#visible() ? coc#pum#confirm() : "\<C-g>u\<TAB>"
" " inoremap <silent><expr> <CR> coc#pum#visible() ? coc#pum#confirm()
"                               " \: "\<C-g>u\<CR>\<c-r>=coc#on_enter()\<CR>"
"
" function! CheckBackspace() abort
"   let col = col('.') - 1
"   return !col || getline('.')[col - 1]  =~# '\s'
" endfunction
"
"
" " See preview of function definition with Shift-k
" function! ShowDocumentation()
"   if CocAction('hasProvider', 'hover')
"     call CocActionAsync('doHover')
"   else
"     call feedkeys('gd', 'in')
"   endif
" endfunction
" " Use K to show documentation in preview window
" nnoremap <silent> gd :call ShowDocumentation()<CR>
"
" " Scroll documentation window
" " See https://github.com/neoclide/coc.nvim/issues/609
" nnoremap coc#float#has_scroll() ? coc#float#scroll(1, 1) : "<Up>"
" nnoremap coc#float#has_scroll() ? coc#float#scroll(0, 1) : "<Down>"
" ----------------------------------------


" Setup for Telescope file_browser picker 
" See repo https://github.com/nvim-telescope/telescope-file-browser.nvim
lua <<
	-- You don't need to set any of these options.
	-- IMPORTANT!: this is only a showcase of how you can set default options!
	require("telescope").setup {
		extensions = {
			file_browser = {
					  theme = "ivy",
							-- disables netrw and use telescope-file-browser in its place
								  hijack_netrw = true,
								  mappings = {
									  ["i"] = {
													-- your custom insert mode mappings
															
										  },
										  ["n"] = {
														-- your custom normal mode mappings
																
											  },
													
									  },
				},
				  
			},
			
		}
	-- To get telescope-file-browser loaded and working with telescope,
	-- you need to call load_extension, somewhere after setup function:
	require("telescope").load_extension "file_browser"
.

" Find files using Telescope command-line sugar.
nnoremap <leader>ff <cmd>Telescope find_files<cr>
nnoremap <leader>fg <cmd>Telescope live_grep<cr>
nnoremap <leader>b <cmd>Telescope buffers<cr>
nnoremap <leader>help <cmd>Telescope help_tags<cr>
nnoremap <leader>gs <cmd>Telescope git_status<cr>
nnoremap <leader>gc <cmd>Telescope git_commits<cr>
nnoremap <leader>tree <cmd>Telescope treesitter<cr>

lua<<
	-- open file_browser with the path of the current buffer
	-- show hidden files by default
	vim.api.nvim_set_keymap(
	  "n",
	  "<space>fb",
	  ":Telescope file_browser hidden=true path=%:p:h select_buffer=true<CR>",
	  { noremap = true  }
	)
.


" Setup lualine
" using all default 
lua<<
	require('lualine').setup{
		options = { theme = 'gruvbox' }
	}
.

" Setup tabline
" See https://github.com/crispgm/nvim-tabline
" lua<<
"     require('tabline').setup({
"         show_index = true,           -- show tab index
"         show_modify = true,          -- show buffer modification indicator
"         show_icon = false,           -- show file extension icon
"         fnamemodify = ':t',          -- file name modifier
"         modify_indicator = '[+]',    -- modify indicator
"         no_name = 'No name',         -- no name buffer name
"         brackets = { '[', ']' },     -- file name brackets surrounding
"         inactive_tab_max_length = 0  -- max length of inactive tab titles, 0 to ignore
"     })
" .

" See https://github.com/akinsho/bufferline.nvim
set termguicolors
lua << 
	require("bufferline").setup{}
.

" --------------------------- nvim-compe (autocomplete) ------------------------
"  taken from https://github.com/hrsh7th/nvim-cmp
"

lua <<EOF
  -- Set up nvim-cmp.
  local cmp = require'cmp'

  cmp.setup({
    snippet = {
      -- REQUIRED - you must specify a snippet engine
      expand = function(args)
        vim.fn["vsnip#anonymous"](args.body) -- For `vsnip` users.
        -- require('luasnip').lsp_expand(args.body) -- For `luasnip` users.
        -- require('snippy').expand_snippet(args.body) -- For `snippy` users.
        -- vim.fn["UltiSnips#Anon"](args.body) -- For `ultisnips` users.
      end,
    },
    window = {
	  completion = cmp.config.window.bordered(),
      documentation = cmp.config.window.bordered(),
    },
    mapping = cmp.mapping.preset.insert({
      ['<C-k>'] = cmp.mapping.scroll_docs(-4),
      ['<C-j>'] = cmp.mapping.scroll_docs(4),
      ['<C-Space>'] = cmp.mapping.complete(),
      ['<C-e>'] = cmp.mapping.abort(),
      ['<Tab>'] = cmp.mapping.confirm({ select = true }), -- Accept currently selected item. Set `select` to `false` to only confirm explicitly selected items.
    }),
    sources = cmp.config.sources({
	  { name = 'copilot' },
      { name = 'nvim_lsp' },
      { name = 'vsnip' }, -- For vsnip users.
      -- { name = 'luasnip' }, -- For luasnip users.
      -- { name = 'ultisnips' }, -- For ultisnips users.
      -- { name = 'snippy' }, -- For snippy users
      { name = 'buffer' }
  	})
  })

  -- Set configuration for specific filetype.
  cmp.setup.filetype('gitcommit', {
    sources = cmp.config.sources({
      { name = 'git' }, -- You can specify the `git` source if [you were installed it](https://github.com/petertriho/cmp-git).
    }, {
      { name = 'buffer' },
    })
  })

  -- Use buffer source for `/` and `?` (if you enabled `native_menu`, this won't work anymore).
  cmp.setup.cmdline({ '/', '?' }, {
    mapping = cmp.mapping.preset.cmdline(),
    sources = {
      { name = 'buffer' }
    }
  })

  -- Use cmdline & path source for ':' (if you enabled `native_menu`, this won't work anymore).
  cmp.setup.cmdline(':', {
    mapping = cmp.mapping.preset.cmdline(),
    sources = cmp.config.sources({
      { name = 'path' }
    }, {
      { name = 'cmdline' }
	})
  })

  -- Set up lspconfig.
  local capabilities = require('cmp_nvim_lsp').default_capabilities()
  -- Replace <YOUR_LSP_SERVER> with each lsp server you've enabled.
  require('lspconfig')['pyright'].setup {
    capabilities = capabilities
  }
  require('lspconfig')['clangd'].setup {
	  capabilities = capabilities
  }
EOF



" --------------------- Copilot -------------
" function! EnableCopilot()
"     " Enable Copilot
"     execute ":Copilot enable"
"     " Map CR to default autocomplete
" lua <<EOF
"     local cmp = require'cmp'
"     cmp.setup({
"         mapping = cmp.mapping.preset.insert({
"               ['<C-k>'] = cmp.mapping.scroll_docs(-4),
"               ['<C-j>'] = cmp.mapping.scroll_docs(4),
"               ['<C-Space>'] = cmp.mapping.complete(),
"               ['<C-e>'] = cmp.mapping.abort(),
"               ['<CR>'] = cmp.mapping.confirm({ select = true }), -- Accept currently selected item. Set `select` to `false` to only confirm explicitly selected items.
"             })
"     })
" EOF
" endfunction
"
" function! DisableCopilot()
"     " Redo mapping to autocomplete
" lua <<EOF
"     local cmp = require'cmp'
"     cmp.setup({
"         mapping = cmp.mapping.preset.insert({
"               ['<C-k>'] = cmp.mapping.scroll_docs(-4),
"               ['<C-j>'] = cmp.mapping.scroll_docs(4),
"               ['<C-Space>'] = cmp.mapping.complete(),
"               ['<C-e>'] = cmp.mapping.abort(),
"               ['<Tab>'] = cmp.mapping.confirm({ select = true }), -- Accept currently selected item. Set `select` to `false` to only confirm explicitly selected items.
"             })
"     })
" EOF
" endfunction
"
" command! -nargs=0 EnableCopilot :call EnableCopilot()
" command! -nargs=0 DisableCopilot :call DisableCopilot()
"
lua << 
	vim.g.copilot_no_tab_map = true

	vim.api.nvim_set_keymap("i", "<S-Tab>", 'copilot#Accept("<CR>")', { silent = true, expr = true })
.

autocmd Filetype javascript set sw=2 ts=2 sts=2
autocmd Filetype javascriptreact set sw=2 ts=2 sts=2
autocmd Filetype html set sw=2 ts=2 sts=2
autocmd Filetype css set sw=2 ts=2 sts=2

" ------------------------------------------------
" Avoding with nested nvim sessions
" ------------------------------------------------

" SEE: https://github.com/mhinz/neovim-remote
" Use nvr as git commit editor
if has('nvim')
  let $GIT_EDITOR = 'nvr -cc split --remote-wait'
endif
" So simple :wq exits commit editor
autocmd FileType gitcommit,gitrebase,gitconfig set bufhidden=delete
